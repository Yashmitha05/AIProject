<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>FocusMate</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
<script src="https://unpkg.com/@tensorflow-models/coco-ssd@2.2.3/dist/coco-ssd.min.js"></script>
<link rel="stylesheet" href="styles.css">
</head>

<body data-theme="pastel-green">

<div class="app-shell">
  <header class="app-header">
    <div class="app-title-group">
      <div class="app-title">FocusMate</div>
      <div class="app-subtitle">Gentle, real-time focus guidance for deep study sessions.</div>
    </div>
    <div style="display:flex; align-items:center; gap:12px;">
      <div class="status-pill">
        <span class="status-dot"></span>
        <span id="sessionStatusLabel">Idle</span>
      </div>
      <div class="theme-toggle-group" aria-label="Theme switcher">
        <button class="theme-toggle-btn is-active" data-theme-btn data-theme-value="pastel-green" type="button">
          <span></span> Calm Green
        </button>
        <button class="theme-toggle-btn" data-theme-btn data-theme-value="pastel-purple" type="button">
          <span></span> Soft Purple
        </button>
        <button class="theme-toggle-btn" data-theme-btn data-theme-value="pastel-gold" type="button">
          <span></span> Soft Gold
        </button>
      </div>
    </div>
  </header>

  <div class="tip-strip" aria-live="polite">
    <span class="tip-icon">ðŸ’¡</span>
    <span class="tip-text" id="tipText">Warning triggers only after 5+ seconds of eyes closed â€” blinks are ignored.</span>
  </div>

  <main class="main-layout">
    <section class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Camera Focus View</div>
          <div class="card-caption">Keep your eyes softly on the screen â€” weâ€™ll handle the rest.</div>
        </div>
      </div>

      <div class="camera-wrapper">
        <video id="video" autoplay playsinline muted></video>
        <canvas id="canvas"></canvas>
      </div>

      <div class="session-controls">
        <div class="button-row">
          <button class="btn btn-primary" id="startBtn" type="button" onclick="startCamera()">
            Start Session
          </button>
          <button class="btn btn-soft" id="stopBtn" type="button" onclick="stopCamera()">
            Pause
          </button>
        </div>
        <div id="sessionPill" class="session-pill">
          <span class="session-dot"></span>
          <span id="sessionStatusText">Ready when you are.</span>
        </div>
      </div>
    </section>

    <aside class="card">
      <div class="card-header">
        <div>
          <div class="card-title">Focus Metrics</div>
          <div class="card-caption">Gentle indicators to keep you aware without pressure.</div>
        </div>
      </div>

      <div class="metrics-grid">
        <div class="metric-card timer-card">
          <div class="metric-label">Study Timer</div>
          <div class="timer-display" id="timerDisplay">00:00:00</div>
          <div class="timer-controls">
            <div class="timer-input-group">
              <input type="number" id="timerHours" class="timer-input" min="0" max="23" value="0" placeholder="0">
              <span class="timer-separator">:</span>
              <input type="number" id="timerMinutes" class="timer-input" min="0" max="59" value="25" placeholder="25">
              <span class="timer-separator">:</span>
              <input type="number" id="timerSeconds" class="timer-input" min="0" max="59" value="0" placeholder="0">
            </div>
            <div class="timer-buttons">
              <button class="timer-btn timer-btn-start" id="timerStartBtn" onclick="startTimer()">Start</button>
              <button class="timer-btn timer-btn-pause" id="timerPauseBtn" onclick="pauseTimer()" style="display:none;">Pause</button>
              <button class="timer-btn timer-btn-reset" id="timerResetBtn" onclick="resetTimer()">Reset</button>
            </div>
          </div>
          <div class="metric-sub">Set your study session duration and stay focused.</div>
        </div>

        <div class="metric-card">
          <div class="metric-label">PERCLOS</div>
          <div class="metric-value"><span id="perclosVal">-</span></div>
          <div class="metric-sub">% of time eyes closed (60s window). Warning at 5+ sec sustained closure; blinks ignored (smoothed EAR + hysteresis).</div>
        </div>
        
        <div class="metric-card">
          <div class="metric-label">Phone Detection</div>
          <div class="metric-value"><span id="phoneStatus">Not Detected</span></div>
          <div class="metric-sub">Alerts when phone is detected in view.</div>
        </div>

        <div class="metric-card">
          <div class="metric-label">Session Status</div>
          <div class="metric-value"><span id="sessionStatus">Idle</span></div>
          <div class="metric-sub">Updates as you focus, blink, or look away.</div>
        </div>

        <div class="metric-card">
          <div class="metric-label">Focus Message</div>
          <div class="status-text" id="status">Waitingâ€¦</div>
        </div>
      </div>

      <div class="accent-bar" aria-hidden="true"></div>

      <div class="focus-footer">
        <span class="focus-footer-text">FocusMate Â· Stay alert, stay present</span>
      </div>
    </aside>
  </main>

  <footer class="app-footer">
    <span>PERCLOS-based drowsiness detection Â· Smoothed EAR + hysteresis</span>
  </footer>
</div>

<script>
const LEFT_EYE = [33, 160, 158, 133, 153, 144];
const RIGHT_EYE = [362, 385, 387, 263, 373, 380];
const PERCLOS_WINDOW_SECONDS = 60.0;
const PERCLOS_DROWSY_THRESHOLD = 0.5;
const PERCLOS_ALERT_THRESHOLD = 0.8;
const EAR_SMOOTH_FRAMES = 11;
const EAR_THRESHOLD_CLOSED = 0.15;
const EAR_THRESHOLD_OPEN = 0.23;
const EYES_CLOSED_WARNING_SECONDS = 5.0;
const MIN_CLOSURE_BEFORE_COUNT_MS = 650;
const OCCLUSION_DETECTION_TIME_SECONDS = 2.5;
const LANDMARK_JITTER_THRESHOLD = 0.05;
const PERCLOS_VARIANCE_THRESHOLD = 0.2;
const PHONE_DETECTION_CONFIDENCE = 0.5;
const PHONE_ALERT_DURATION_SECONDS = 2.0;
const PHONE_DETECTION_INTERVAL = 5;

const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
const statusEl = document.getElementById("status");
const perclosEl = document.getElementById("perclosVal");
const phoneStatusEl = document.getElementById("phoneStatus");
const sessionStatusEl = document.getElementById("sessionStatus");
const sessionStatusLabelEl = document.getElementById("sessionStatusLabel");
const sessionStatusTextEl = document.getElementById("sessionStatusText");

let stream = null;
let alarmPlaying = false;
let currentLeftEyePoints = null;
let currentRightEyePoints = null;
let perclosFrameHistory = [];
let earHistory = [];
let smoothedEarState = 'open';
const FOCUS_STATE = { FOCUSED: 'FOCUSED', EYES_OCCLUDED: 'EYES_OCCLUDED', ALERT: 'ALERT' };
let currentFocusState = FOCUS_STATE.FOCUSED;
let eyeClosedSince = null;
let eyesOpenSince = null;
let noFaceSince = null;
let occlusionDetectedSince = null;
let previousLeftEyePoints = null;
let previousRightEyePoints = null;
let perclosHistory = [];
const PERCLOS_HISTORY_SIZE = 10;
let phoneDetectionModel = null;
let phoneDetectedSince = null;
let phoneDetectionFrameCount = 0;
let isPhoneDetected = false;
let timerInterval = null;
let timerTotalSeconds = 0;
let timerRemainingSeconds = 0;
let timerIsRunning = false;
let timerIsPaused = false;

function formatTime(seconds) {
  const hrs = Math.floor(seconds / 3600);
  const mins = Math.floor((seconds % 3600) / 60);
  const secs = seconds % 60;
  return `${String(hrs).padStart(2, '0')}:${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
}

function updateTimerDisplay() {
  const displayEl = document.getElementById('timerDisplay');
  if (!displayEl) return;
  
  displayEl.textContent = formatTime(timerRemainingSeconds);
  if (timerRemainingSeconds > 0 && timerRemainingSeconds <= 60) {
    displayEl.classList.add('warning');
  } else {
    displayEl.classList.remove('warning');
  }
}

function startTimer() {
  const hoursInput = document.getElementById('timerHours');
  const minutesInput = document.getElementById('timerMinutes');
  const secondsInput = document.getElementById('timerSeconds');
  const startBtn = document.getElementById('timerStartBtn');
  const pauseBtn = document.getElementById('timerPauseBtn');
  
  if (!timerIsRunning && !timerIsPaused) {
    const hours = parseInt(hoursInput.value) || 0;
    const minutes = parseInt(minutesInput.value) || 0;
    const seconds = parseInt(secondsInput.value) || 0;
    
    timerTotalSeconds = hours * 3600 + minutes * 60 + seconds;
    timerRemainingSeconds = timerTotalSeconds;
    
    if (timerTotalSeconds <= 0) {
      alert('Please set a valid timer duration.');
      return;
    }
    hoursInput.disabled = true;
    minutesInput.disabled = true;
    secondsInput.disabled = true;
  }
  
  timerIsRunning = true;
  timerIsPaused = false;
  
  startBtn.style.display = 'none';
  pauseBtn.style.display = 'inline-flex';
  
  timerInterval = setInterval(() => {
    if (timerRemainingSeconds > 0) {
      timerRemainingSeconds--;
      updateTimerDisplay();
    } else {
      clearInterval(timerInterval);
      timerInterval = null;
      timerIsRunning = false;
      timerIsPaused = false;
      startAlarm();
      alert('Study session complete! ðŸŽ‰ Time for a well-deserved break.');
      startBtn.style.display = 'inline-flex';
      pauseBtn.style.display = 'none';
      hoursInput.disabled = false;
      minutesInput.disabled = false;
      secondsInput.disabled = false;
      resetTimer();
    }
  }, 1000);
  
  updateTimerDisplay();
}

function pauseTimer() {
  if (!timerIsRunning) return;
  
  clearInterval(timerInterval);
  timerInterval = null;
  timerIsRunning = false;
  timerIsPaused = true;
  
  const startBtn = document.getElementById('timerStartBtn');
  const pauseBtn = document.getElementById('timerPauseBtn');
  startBtn.style.display = 'inline-flex';
  pauseBtn.style.display = 'none';
}

function resetTimer() {
  clearInterval(timerInterval);
  timerInterval = null;
  timerIsRunning = false;
  timerIsPaused = false;
  
  timerRemainingSeconds = 0;
  timerTotalSeconds = 0;
  
  const hoursInput = document.getElementById('timerHours');
  const minutesInput = document.getElementById('timerMinutes');
  const secondsInput = document.getElementById('timerSeconds');
  const startBtn = document.getElementById('timerStartBtn');
  const pauseBtn = document.getElementById('timerPauseBtn');
  
  hoursInput.disabled = false;
  minutesInput.disabled = false;
  secondsInput.disabled = false;
  
  startBtn.style.display = 'inline-flex';
  pauseBtn.style.display = 'none';
  
  updateTimerDisplay();
}

let attentionAudio = null;
function startAlarm(){
  if(alarmPlaying) return;
  if(!attentionAudio){
    attentionAudio = new Audio('attention.mp3');
    attentionAudio.loop = true;
  }
  attentionAudio.currentTime = 0;
  attentionAudio.play().catch(() => {});
  alarmPlaying = true;
}
function stopAlarm(){
  if(!alarmPlaying) return;
  if(attentionAudio){
    attentionAudio.pause();
    attentionAudio.currentTime = 0;
  }
  alarmPlaying = false;
}

function dist(a,b){ return Math.hypot(a.x - b.x, a.y - b.y); }

function computeEyeClosure(landmarks, idx){
  if(!landmarks || landmarks.length < Math.max(...idx) + 1) return 1.0;
  const p = idx.map(i => (i >= landmarks.length || !landmarks[i]) ? null : landmarks[i]);
  if(p.some(lm => lm === null)) return 1.0;
  const A = dist(p[1], p[5]);
  const B = dist(p[2], p[4]);
  const C = dist(p[0], p[3]) + 1e-6;
  return (A + B) / (2.0 * C);
}

function calculatePERCLOS(frameHistory, windowSeconds){
  const currentTime = performance.now();
  const windowStart = currentTime - (windowSeconds * 1000);
  const framesInWindow = frameHistory.filter(frame => frame.timestamp >= windowStart);
  if(framesInWindow.length === 0) return 0;
  const closedFrames = framesInWindow.filter(frame => frame.isClosed).length;
  return (closedFrames / framesInWindow.length) * 100;
}

function calculateLandmarkJitter(currentPoints, previousPoints){
  if(!currentPoints || !previousPoints || currentPoints.length !== previousPoints.length) return 0;
  let maxJitter = 0;
  for(let i = 0; i < currentPoints.length; i++){
    const dx = Math.abs(currentPoints[i].x - previousPoints[i].x);
    const dy = Math.abs(currentPoints[i].y - previousPoints[i].y);
    maxJitter = Math.max(maxJitter, Math.hypot(dx, dy));
  }
  return maxJitter;
}

function calculatePERCLOSVariance(perclosHistory){
  if(perclosHistory.length < 3) return 0;
  const mean = perclosHistory.reduce((a, b) => a + b, 0) / perclosHistory.length;
  return perclosHistory.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / perclosHistory.length;
}

function detectOcclusion(leftEyePoints, rightEyePoints, eyeClosureMetric, perclosHistory){
  if(!leftEyePoints || !rightEyePoints) return true;
  if(eyeClosureMetric < 0.1) return true;
  if(previousLeftEyePoints && previousRightEyePoints){
    const leftJitter = calculateLandmarkJitter(leftEyePoints, previousLeftEyePoints);
    const rightJitter = calculateLandmarkJitter(rightEyePoints, previousRightEyePoints);
    if(Math.max(leftJitter, rightJitter) > LANDMARK_JITTER_THRESHOLD) return true;
  }
  if(calculatePERCLOSVariance(perclosHistory) > PERCLOS_VARIANCE_THRESHOLD) return true;
  return false;
}

async function loadPhoneDetectionModel(){
  try {
    let attempts = 0;
    while(typeof cocoSsd === 'undefined' && attempts < 50){
      await new Promise(resolve => setTimeout(resolve, 100));
      attempts++;
    }
    if(typeof cocoSsd === 'undefined'){
      console.warn('COCO-SSD library not loaded. Phone detection will be unavailable.');
      phoneStatusEl.innerText = "Unavailable";
      phoneStatusEl.style.color = '#999';
      return false;
    }
    
    phoneStatusEl.innerText = "Loading...";
    phoneStatusEl.style.color = '#ffa500';
    
    phoneDetectionModel = await Promise.race([
      cocoSsd.load(),
      new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 30000))
    ]);
    
    phoneStatusEl.innerText = "Ready";
    phoneStatusEl.style.color = '#00ff00';
    return true;
  } catch(error){
    console.warn('Phone detection unavailable (network/CDN issue):', error.message);
    phoneStatusEl.innerText = "Unavailable";
    phoneStatusEl.style.color = '#999';
    phoneDetectionModel = null;
    return false;
  }
}

async function detectPhoneInFrame(videoElement){
  if(!phoneDetectionModel) return [];
  try {
    const predictions = await phoneDetectionModel.detect(videoElement);
    const phoneDetections = predictions
      .filter(pred => pred.class === 'cell phone' && pred.score >= PHONE_DETECTION_CONFIDENCE)
      .map(pred => {
        const [x, y, width, height] = pred.bbox;
        return {
          bbox: [x, y, x + width, y + height],
          confidence: pred.score,
          class: 'cell phone'
        };
      });
    
    return phoneDetections;
  } catch(error){
    console.error('Phone detection error:', error);
    return [];
  }
}

function drawPhoneDetections(detections){
  if(!detections || detections.length === 0) return;
  detections.forEach(detection => {
    const [x1, y1, x2, y2] = detection.bbox;
    ctx.strokeStyle = '#ff0000';
    ctx.lineWidth = 3;
    ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
    ctx.fillStyle = '#ff0000';
    ctx.font = '16px Arial';
    ctx.fillText(
      `Phone ${(detection.confidence * 100).toFixed(0)}%`,
      x1,
      y1 - 5
    );
  });
}

function getEyePoints(landmarks, eyeIndices){
  if(!landmarks || landmarks.length < Math.max(...eyeIndices) + 1) return null;
  if(!canvas || canvas.width === 0 || canvas.height === 0) return null;
  const points = [];
  for(let i = 0; i < eyeIndices.length; i++){
    const idx = eyeIndices[i];
    if(idx >= landmarks.length || !landmarks[idx]) return null;
    const lm = landmarks[idx];
    points.push({ x: lm.x * canvas.width, y: lm.y * canvas.height });
  }
  return points.length === 6 ? points : null;
}

const themeButtons = document.querySelectorAll("[data-theme-btn]");
const bodyEl = document.body;

themeButtons.forEach(btn => {
  btn.addEventListener("click", () => {
    const theme = btn.getAttribute("data-theme-value");
    if(!theme) return;

    bodyEl.setAttribute("data-theme", theme);

    themeButtons.forEach(b => b.classList.remove("is-active"));
    btn.classList.add("is-active");
  });
});

const faceMesh = new FaceMesh({
  locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
});
faceMesh.setOptions({
  maxNumFaces: 1,
  refineLandmarks: true,
  minDetectionConfidence: 0.5,
  minTrackingConfidence: 0.5
});

faceMesh.onResults(results => {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);
  const currentTime = performance.now();

  if(!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0){
    if(noFaceSince === null) noFaceSince = currentTime;
    eyeClosedSince = null;
    eyesOpenSince = null;
    occlusionDetectedSince = null;
    currentLeftEyePoints = null;
    currentRightEyePoints = null;
    previousLeftEyePoints = null;
    previousRightEyePoints = null;
    perclosFrameHistory = [];
    perclosHistory = [];
    earHistory = [];
    smoothedEarState = 'open';
    if(currentFocusState !== FOCUS_STATE.FOCUSED){
      currentFocusState = FOCUS_STATE.FOCUSED;
      stopAlarm();
    }
    
    const noFaceTime = (currentTime - noFaceSince) / 1000;
    if(noFaceTime >= 1.0){
      statusEl.innerText = "âš ï¸ Eyes not visible â€” Please look at the camera!";
      statusEl.className = "status-bad";
      startAlarm();
      sessionStatusEl.innerText = "Looking Away";
      sessionStatusLabelEl.innerText = "Paused";
      sessionStatusTextEl.innerText = "Eyes not visible (looking away). We'll resume when you're back in view.";
    } else {
      statusEl.innerText = "Eyes not visible â€” Please look at the camera.";
      statusEl.className = "status-bad";
      stopAlarm();
      sessionStatusEl.innerText = "Not in View";
      sessionStatusLabelEl.innerText = "Idle";
      sessionStatusTextEl.innerText = "When you're ready, look at the screen.";
    }
    perclosEl.innerText = "-";
    return;
  }
  noFaceSince = null;
  const landmarks = results.multiFaceLandmarks[0];
  const leftEyeClosure = computeEyeClosure(landmarks, LEFT_EYE);
  const rightEyeClosure = computeEyeClosure(landmarks, RIGHT_EYE);
  const avgEyeClosure = (leftEyeClosure + rightEyeClosure) / 2;
  currentLeftEyePoints = getEyePoints(landmarks, LEFT_EYE);
  currentRightEyePoints = getEyePoints(landmarks, RIGHT_EYE);

  earHistory.push(avgEyeClosure);
  if(earHistory.length > EAR_SMOOTH_FRAMES) earHistory.shift();
  const smoothedEAR = earHistory.length >= EAR_SMOOTH_FRAMES
    ? earHistory.reduce((a, b) => a + b, 0) / earHistory.length
    : avgEyeClosure;
  if(smoothedEAR < EAR_THRESHOLD_CLOSED) smoothedEarState = 'closed';
  else if(smoothedEAR > EAR_THRESHOLD_OPEN) smoothedEarState = 'open';
  const isEyesClosedThisFrame = smoothedEarState === 'closed';

  perclosFrameHistory.push({ timestamp: currentTime, isClosed: isEyesClosedThisFrame });
  const windowStart = currentTime - (PERCLOS_WINDOW_SECONDS * 1000);
  perclosFrameHistory = perclosFrameHistory.filter(frame => frame.timestamp >= windowStart);
  const currentPERCLOS = calculatePERCLOS(perclosFrameHistory, PERCLOS_WINDOW_SECONDS);
  perclosEl.innerText = `${currentPERCLOS.toFixed(1)}%`;

  perclosHistory.push(currentPERCLOS);
  if(perclosHistory.length > PERCLOS_HISTORY_SIZE) perclosHistory.shift();

  const isOcclusionDetected = detectOcclusion(
    currentLeftEyePoints, 
    currentRightEyePoints, 
    avgEyeClosure, 
    perclosHistory
  );
  if(isOcclusionDetected){
    if(occlusionDetectedSince === null) occlusionDetectedSince = currentTime;
  } else {
    occlusionDetectedSince = null;
  }
  const occlusionDuration = occlusionDetectedSince !== null 
    ? (currentTime - occlusionDetectedSince) / 1000 
    : 0;
  const isOccluded = occlusionDuration >= OCCLUSION_DETECTION_TIME_SECONDS;
  if(isOccluded){
    eyeClosedSince = null;
    eyesOpenSince = null;
    if(currentFocusState !== FOCUS_STATE.EYES_OCCLUDED) currentFocusState = FOCUS_STATE.EYES_OCCLUDED;
    statusEl.innerText = "âš ï¸ Eyes Occluded â€” Please ensure eyes are clearly visible!";
    statusEl.className = "status-bad";
    sessionStatusEl.innerText = "Eyes Occluded";
    sessionStatusLabelEl.innerText = "Not Focused";
    sessionStatusTextEl.innerText = "We cannot reliably detect your eyes. Please remove any obstructions.";
    stopAlarm();
    previousLeftEyePoints = currentLeftEyePoints;
    previousRightEyePoints = currentRightEyePoints;
    return;
  }
  occlusionDetectedSince = null;
  previousLeftEyePoints = currentLeftEyePoints;
  previousRightEyePoints = currentRightEyePoints;

  if(isEyesClosedThisFrame){
    if(eyeClosedSince === null) eyeClosedSince = currentTime;
  } else {
    eyeClosedSince = null;
  }
  const closedDurationMs = eyeClosedSince !== null ? currentTime - eyeClosedSince : 0;
  const closedDurationSec = closedDurationMs / 1000;
  const isSustainedClosure = closedDurationMs >= MIN_CLOSURE_BEFORE_COUNT_MS;
  const isEyesClosed = isEyesClosedThisFrame && isSustainedClosure;

  if(isEyesClosed && closedDurationSec >= EYES_CLOSED_WARNING_SECONDS){
    currentFocusState = FOCUS_STATE.ALERT;
    statusEl.innerText = "âš ï¸ Eyes not visible â€” closed 5+ seconds. Please stay alert!";
    statusEl.className = "status-bad";
    startAlarm();
    sessionStatusEl.innerText = "Eyes Not Visible";
    sessionStatusLabelEl.innerText = "Alert";
    sessionStatusTextEl.innerText = "Eyes closed 5+ seconds (blinks ignored). Possible drowsiness.";
  } else if(isEyesClosed){
    currentFocusState = FOCUS_STATE.FOCUSED;
    stopAlarm();
    statusEl.innerText = `Eyes closed (${closedDurationSec.toFixed(1)}s) â€” warning at 5s`;
    statusEl.className = "status-ok";
    sessionStatusEl.innerText = "Eyes Closed";
    sessionStatusLabelEl.innerText = "Tracking";
    sessionStatusTextEl.innerText = "Brief closure. Warning only if eyes stay closed 5+ seconds.";
  } else {
    stopAlarm();
    currentFocusState = FOCUS_STATE.FOCUSED;
    statusEl.innerText = "Focused âœ“";
    statusEl.className = "status-ok";
    sessionStatusEl.innerText = "Focused";
    sessionStatusLabelEl.innerText = "Calm Focus";
    sessionStatusTextEl.innerText = "Smoothed EAR + hysteresis: warning only when eyes closed 5+ sec (blinks ignored).";
  }

  phoneDetectionFrameCount++;
  if(phoneDetectionFrameCount >= PHONE_DETECTION_INTERVAL){
    phoneDetectionFrameCount = 0;
    detectPhoneInFrame(video).then(detections => {
      const phoneDetected = detections.length > 0;
      if(phoneDetected){
        if(phoneDetectedSince === null) phoneDetectedSince = currentTime;
        const phoneDuration = (performance.now() - phoneDetectedSince) / 1000;
        phoneStatusEl.innerText = `Detected (${phoneDuration.toFixed(1)}s)`;
        phoneStatusEl.style.color = '#ff0000';
        drawPhoneDetections(detections);
        if(phoneDuration >= PHONE_ALERT_DURATION_SECONDS && statusEl.innerText.includes("Focused")){
            statusEl.innerText = "âš ï¸ Phone Detected â€” Please put your phone away!";
            statusEl.className = "status-bad";
            startAlarm();
            sessionStatusEl.innerText = "Phone Detected";
            sessionStatusLabelEl.innerText = "Distraction";
            sessionStatusTextEl.innerText = "A phone has been detected. Please put it away to maintain focus.";
        }
      } else {
        phoneDetectedSince = null;
        phoneStatusEl.innerText = "Not Detected";
        phoneStatusEl.style.color = '';
      }
    }).catch(error => {
      console.error('Phone detection error:', error);
    });
  }
  previousLeftEyePoints = currentLeftEyePoints;
  previousRightEyePoints = currentRightEyePoints;
});

async function startCamera(){
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video:true });
    video.srcObject = stream;
    await video.play();
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    
    if(!phoneDetectionModel){
      loadPhoneDetectionModel().catch(() => {
        phoneStatusEl.innerText = "Unavailable";
        phoneStatusEl.style.color = '#999';
      });
    }

    async function loop(){
      if(!stream) return;
      await faceMesh.send({ image: video });
      requestAnimationFrame(loop);
    }
    loop();
  } catch(error){
    if(error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError'){
      alert('Camera permission denied. Please allow camera access and try again.');
      phoneStatusEl.innerText = "Camera Denied";
      phoneStatusEl.style.color = '#ff0000';
    } else if(error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError'){
      alert('No camera found. Please connect a camera and try again.');
      phoneStatusEl.innerText = "No Camera";
      phoneStatusEl.style.color = '#ff0000';
    } else {
      alert('Failed to start camera: ' + error.message);
      phoneStatusEl.innerText = "Error";
      phoneStatusEl.style.color = '#ff0000';
    }
    console.error('Camera error:', error);
  }
}

function stopCamera(){
  if(stream){
    stream.getTracks().forEach(t => t.stop());
    stream = null;
  }
  stopAlarm();
  currentFocusState = FOCUS_STATE.FOCUSED;
  eyeClosedSince = null;
  eyesOpenSince = null;
  noFaceSince = null;
  occlusionDetectedSince = null;
  previousLeftEyePoints = null;
  previousRightEyePoints = null;
  perclosFrameHistory = [];
  perclosHistory = [];
  phoneDetectedSince = null;
  phoneDetectionFrameCount = 0;
  isPhoneDetected = false;
  earHistory = [];
  smoothedEarState = 'open';
  perclosEl.innerText = "-";
  phoneStatusEl.innerText = "Not Detected";
  phoneStatusEl.style.color = '';
  statusEl.innerText = "Stopped";
}

const TIPS = [
  "Warning triggers only after 5+ seconds of eyes closed â€” blinks are ignored.",
  "PERCLOS measures % of time eyes are closed over the last 60 seconds.",
  "Keep your face in view for best detection. Looking away shows \"Eyes not visible\".",
  "The study timer can run independently â€” set it and start your session.",
  "Smoothed EAR + hysteresis reduces false alerts from brief eye movements.",
];
let tipIndex = 0;
function cycleTip() {
  const el = document.getElementById('tipText');
  if (el) { el.textContent = TIPS[tipIndex % TIPS.length]; tipIndex++; }
}

document.addEventListener('DOMContentLoaded', () => {
  updateTimerDisplay();
  cycleTip();
  setInterval(cycleTip, 8000);
});
</script>

</body>
</html>
